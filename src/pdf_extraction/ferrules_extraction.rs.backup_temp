// Ferrules-based extraction for better structured text with proper word boundaries
use anyhow::Result;
use std::path::Path;
use std::process::Command;
use serde::{Deserialize, Serialize};
use ferrules_core::*;
use std::collections::HashMap;

#[derive(Debug, Deserialize, Serialize)]
struct FerrulesOutput {
    doc_name: String,
    pages: Vec<FerrulesPage>,
    blocks: Vec<FerrulesBlock>,
    metadata: serde_json::Value,
}

#[derive(Debug, Deserialize, Serialize)]
struct FerrulesPage {
    id: usize,
    width: f32,
    height: f32,
    need_ocr: bool,
}

#[derive(Debug, Deserialize, Serialize)]
struct FerrulesBlockKind {
    block_type: String,
    text: String,
}

#[derive(Debug, Deserialize, Serialize, Clone, Copy)]
struct FerrulesBBox {
    x0: f32,
    y0: f32,
    x1: f32,
    y1: f32,
}

#[derive(Debug, Deserialize, Serialize)]
struct FerrulesBlock {
    id: usize,
    kind: FerrulesBlockKind,
    pages_id: Vec<usize>,
    bbox: FerrulesBBox,
}

/// Extract text using Ferrules for better structure and word boundaries
pub async fn extract_with_ferrules(
    pdf_path: &Path,
    page_index: usize,
    width: usize,
    height: usize,
) -> Result<Vec<Vec<char>>> {
    // First, try to run Ferrules as a subprocess
    let ferrules_path = "./ferrules/target/release/ferrules";
    
    // Check if Ferrules exists
    if !std::path::Path::new(ferrules_path).exists() {
        anyhow::bail!("Ferrules not found at {}", ferrules_path);
    }
    
    // Create a temp directory for output
    let temp_dir = std::env::temp_dir().join(format!("ferrules_{}", std::process::id()));
    std::fs::create_dir_all(&temp_dir)?;
    
    // Run Ferrules
    let output = Command::new(ferrules_path)
        .args(&[
            pdf_path.to_str().unwrap(),
            "-r", &format!("{}", page_index + 1), // Ferrules uses 1-based page numbers
            "-o", temp_dir.to_str().unwrap(),
        ])
        .output()?;
    
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        let stdout = String::from_utf8_lossy(&output.stdout);
        println!("Ferrules stderr: {}", stderr);
        println!("Ferrules stdout: {}", stdout);
        anyhow::bail!("Ferrules failed: {}", stderr);
    }
    
    // Process Ferrules output
    let _stdout = String::from_utf8_lossy(&output.stdout);
    
    // Find the output JSON file - look recursively since Ferrules might create subdirs
    let mut json_files = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&temp_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                // Look in subdirectories
                if let Ok(sub_entries) = std::fs::read_dir(&path) {
                    for sub_entry in sub_entries.flatten() {
                        let sub_path = sub_entry.path();
                        if sub_path.extension().and_then(|ext| ext.to_str()) == Some("json") {
                            json_files.push(sub_entry);
                        }
                    }
                }
            } else if path.extension().and_then(|ext| ext.to_str()) == Some("json") {
                json_files.push(entry);
            }
        }
    }
    
    if json_files.is_empty() {
        // Cleanup
        let _ = std::fs::remove_dir_all(&temp_dir);
        anyhow::bail!("No JSON output from Ferrules");
    }
    
    // Read the JSON
    let json_content = std::fs::read_to_string(json_files[0].path())?;
    let ferrules_data: FerrulesOutput = serde_json::from_str(&json_content)?;
    
    // Cleanup temp directory
    let _ = std::fs::remove_dir_all(&temp_dir);
    
    // Get page dimensions
    let page = ferrules_data.pages.iter()
        .find(|p| p.id == page_index)
        .ok_or_else(|| anyhow::anyhow!("Page {} not found", page_index))?;
    
    let page_width = page.width;
    let page_height = page.height;
    
    // Process blocks for this page
    let page_blocks: Vec<_> = ferrules_data.blocks.iter().filter(|b| b.pages_id.contains(&page_index)).collect();
    
    // Advanced visual reconstruction for perfect convergence
    let grid = reconstruct_visual_layout(&page_blocks, page_width, page_height, width, height)?;
    
    // If no blocks found, this suggests Ferrules OCR failed or text extraction failed
    if ferrules_data.blocks.is_empty() {
        if page.need_ocr {
            anyhow::bail!("Ferrules detected OCR needed but returned no blocks - OCR may have failed");
        } else {
            anyhow::bail!("Ferrules returned no text blocks - document may be empty or extraction failed");
        }
    }
    
    Ok(grid)
}

/// Advanced visual layout reconstruction for perfect ground truth convergence
fn reconstruct_visual_layout(
    blocks: &[&FerrulesBlock],
    page_width: f32,
    page_height: f32,
    grid_width: usize,
    grid_height: usize,
) -> Result<Vec<Vec<char>>> {
    // Step 1: Create high-resolution coordinate mapping
    let mut text_elements: Vec<TextElement> = Vec::new();
    
    for block in blocks {
        let text = &block.kind.text;
        let bbox = &block.bbox;
        
        // Convert to normalized coordinates (0.0 to 1.0)
        let norm_x = bbox.x0 / page_width;
        let norm_y = bbox.y0 / page_height;
        let norm_width = (bbox.x1 - bbox.x0) / page_width;
        let norm_height = (bbox.y1 - bbox.y0) / page_height;
        
        text_elements.push(TextElement {
            text: text.clone(),
            x: norm_x,
            y: norm_y, 
            width: norm_width,
            height: norm_height,
            bbox: bbox.clone(),
        });
    }
    
    // Step 2: Intelligent text flow reconstruction
    reconstruct_text_flow(text_elements, grid_width, grid_height)
}

#[derive(Debug, Clone)]
struct TextElement {
    text: String,
    x: f32,
    y: f32,
    width: f32,
    height: f32,
    bbox: FerrulesBBox,
}

#[derive(Debug)]
struct TextLine {
    elements: Vec<TextElement>,
    y_center: f32,
    y_top: f32,
    y_bottom: f32,
}

fn reconstruct_text_flow(
    mut elements: Vec<TextElement>,
    grid_width: usize,
    grid_height: usize,
) -> Result<Vec<Vec<char>>> {
    // Sort elements by vertical position first
    elements.sort_by(|a, b| a.y.partial_cmp(&b.y).unwrap_or(std::cmp::Ordering::Equal));
    
    // Step 1: Group elements into logical text lines with smart tolerance
    let mut lines: Vec<TextLine> = Vec::new();
    let line_tolerance = 0.012; // 1.2% of page height tolerance for same line (tighter grouping)
    
    for element in elements {
        let element_center_y = element.y + element.height / 2.0;
        
        // Find if this element belongs to an existing line
        let mut placed = false;
        for line in &mut lines {
            let y_diff = (element_center_y - line.y_center).abs();
            if y_diff <= line_tolerance {
                line.elements.push(element.clone());
                // Update line boundaries
                line.y_top = line.y_top.min(element.y);
                line.y_bottom = line.y_bottom.max(element.y + element.height);
                line.y_center = (line.y_top + line.y_bottom) / 2.0;
                placed = true;
                break;
            }
        }
        
        // Create new line if not placed
        if !placed {
            lines.push(TextLine {
                y_center: element_center_y,
                y_top: element.y,
                y_bottom: element.y + element.height,
                elements: vec![element],
            });
        }
    }
    
    // Step 2: Sort lines vertically and elements horizontally within each line
    lines.sort_by(|a, b| a.y_center.partial_cmp(&b.y_center).unwrap_or(std::cmp::Ordering::Equal));
    for line in &mut lines {
        line.elements.sort_by(|a, b| a.x.partial_cmp(&b.x).unwrap_or(std::cmp::Ordering::Equal));
    }
    
    // Step 3: Build grid with precise character positioning
    let mut grid = vec![vec![' '; grid_width]; grid_height];
    let mut line_map = HashMap::new();
    
    for (line_idx, line) in lines.iter().enumerate() {
        // Map line to grid row with more precision
        let grid_row = ((1.0 - line.y_center) * grid_height as f32).round() as usize;
        let grid_row = grid_row.min(grid_height - 1);
        
        line_map.insert(line_idx, grid_row);
        
        let mut current_col = 0;
        
        for (elem_idx, element) in line.elements.iter().enumerate() {
            // Calculate precise column position
            let target_col = (element.x * grid_width as f32).round() as usize;
            let target_col = target_col.min(grid_width - 1);
            
            // Handle spacing between elements on same line
            if elem_idx > 0 {
                let prev_element = &line.elements[elem_idx - 1];
                let prev_end_col = ((prev_element.x + prev_element.width) * grid_width as f32).round() as usize;
                let gap = target_col.saturating_sub(prev_end_col);
                
                // Smart spacing: improved gap detection for better word separation
                if gap == 0 {
                    // Elements touch - add single space
                    if current_col < grid_width {
                        grid[grid_row][current_col] = ' ';
                        current_col += 1;
                    }
                } else if gap <= 2 {
                    // Very small gap - single space (common OCR case)
                    current_col = target_col.max(current_col);
                    if current_col > 0 && current_col < grid_width && grid[grid_row][current_col - 1] != ' ' {
                        grid[grid_row][current_col] = ' ';
                        current_col += 1;
                    }
                } else if gap <= 5 {
                    // Medium gap - preserve with minimal spacing
                    current_col = target_col.max(current_col + 1);
                } else {
                    // Larger gap - preserve original spacing for columns/structure
                    current_col = target_col;
                }
            } else {
                current_col = target_col;
            }
            
            // Place the text with proper character spacing
            let text = &element.text;
            for ch in text.chars() {
                if current_col < grid_width && grid_row < grid_height {
                    grid[grid_row][current_col] = ch;
                    current_col += 1;
                } else {
                    break;
                }
            }
        }
    }
    
    // Step 4: Post-process for paragraph detection and formatting
    post_process_layout(&mut grid);
    
    Ok(grid)
}

fn post_process_layout(grid: &mut Vec<Vec<char>>) {
    let height = grid.len();
    let width = if height > 0 { grid[0].len() } else { 0 };
    
    // Detect and preserve paragraph breaks
    let mut paragraph_breaks = Vec::new();
    
    for row in 0..height {
        let line_text: String = grid[row].iter().collect();
        let trimmed = line_text.trim();
        
        if trimmed.is_empty() {
            continue;
        }
        
        // Look for paragraph indicators (indentation, caps, etc.)
        let has_indent = line_text.starts_with("    ") || line_text.starts_with("\t");
        let is_title_case = trimmed.chars().next().map_or(false, |c| c.is_uppercase());
        let prev_line_empty = row > 0 && {
            let prev_text: String = grid[row - 1].iter().collect();
            prev_text.trim().is_empty()
        };
        
        if (has_indent || (is_title_case && prev_line_empty)) && row > 0 {
            paragraph_breaks.push(row - 1);
        }
    }
    
    // Clean up excessive whitespace while preserving structure
    for row in 0..height {
        let line: String = grid[row].iter().collect();
        let cleaned = clean_line_spacing(&line);
        
        // Update the grid row
        for (col, ch) in cleaned.chars().enumerate() {
            if col < width {
                grid[row][col] = ch;
            }
        }
        
        // Fill remaining with spaces
        for col in cleaned.len()..width {
            grid[row][col] = ' ';
        }
    }
}

fn clean_line_spacing(line: &str) -> String {
    // Preserve leading/trailing spaces but clean internal spacing
    let trimmed = line.trim_end();
    let leading_spaces = line.len() - line.trim_start().len();
    
    if trimmed.is_empty() {
        return String::new();
    }
    
    let mut result = String::new();
    result.push_str(&" ".repeat(leading_spaces));
    
    let mut prev_was_space = false;
    for ch in trimmed.trim_start().chars() {
        if ch == ' ' {
            if !prev_was_space {
                result.push(' ');
                prev_was_space = true;
            }
        } else {
            result.push(ch);
            prev_was_space = false;
        }
    }
    
    result
}

